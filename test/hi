#include "fileCompressor.h"

int main(int argc, char* argv[])
{
    
    //compress file
    /*int codebookFD = open("./HuffmanCodebook", O_RDONLY);
    node* root = NULL;
    root = buildAVLFromHuffman(codebookFD, root);
    int oldFD = open("./IO.c", O_RDONLY);
    int compFD = open("./fileCompressorTest.c.hcz", O_RDWR | O_CREAT, 00600);
    compressFile(oldFD, compFD, root);
    freeTree(root);
    close(codebookFD);*/

    //decompress file
    /*int codebookFD = open("./HuffmanCodebook", O_RDONLY);
    node* huffmanTreeRoot = (node*) malloc(sizeof(node));
    huffmanTreeRoot->encoding = NULL;
    huffmanTreeRoot->token = NULL;
    huffmanTreeRoot = buildHuffmanFromFile(codebookFD, huffmanTreeRoot);
    //printHuffman(huffmanTreeRoot);
    int compFD = open("./fileCompressorTest.c.hcz", O_RDONLY);
    int newFD = open("./test1.txt", O_RDWR | O_CREAT, 00600);
    decompressFile(compFD, newFD, huffmanTreeRoot);

    freeHuffman(huffmanTreeRoot);*/

    //recursive build
    /*node* root = NULL;
    root = buildAVLRecursive("./test", root);
    int heapSize = getSize(root);
    node** heap = (node**) malloc(sizeof(node*) * heapSize);
    createHeap(heap, root, 0);
    buildHeap(heap, heapSize);
    buildHuffmanTree(heap, &heapSize);
    int huffmanSize = getSize(heap[0]);
    int* huffmanCodeArr = (int*) malloc(sizeof(int) * huffmanSize);
    int lengthOfEncoding = 0;
    encode(heap[0], huffmanCodeArr, lengthOfEncoding);
    int codebookFD = open("./HuffmanCodebook", O_RDWR | O_CREAT, 00600);
    writeHuffmanCodebook(codebookFD, heap[0]);
    close(codebookFD);
    freeHuffman(heap[0]);
    free(heap);
    free(huffmanCodeArr);*/

    /*if(argv[1][0] == '-' && argv[1][1] == 'b')
    {
        node* root = NULL;
        char* huffmanPath = createHuffmanPath(argv[2]);
        root = buildAVLFromFile(argv[2], root);
        build(root, huffmanPath);
        free(huffmanPath);
    }*/
    node* root = NULL;
    recursiveBuild(root, "./test");

    return 0;
}

void recursiveBuild(node* root, char* path)
{
    char* huffmanPath = (char*) malloc(sizeof(char) * (strlen(path) + 2));
    memset(huffmanPath, '\0', strlen(path)+2);
    strcpy(huffmanPath, path);
    strcat(huffmanPath, "/");
    huffmanPath = createHuffmanPath(huffmanPath);
    if(access(huffmanPath, F_OK) != -1)
    {
        printf("Warning: Codebook already exists in directory, will be deleted and/or replaced\n");
        remove(huffmanPath);
    }
    root = buildAVLRecursive(path, root);
    build(root, huffmanPath);
}

void build(node* root, char* huffmanPath)
{
    int heapSize = getSize(root);
    if(heapSize == 0)
    {
        printf("Fatal Error: no valid directory/file(s) to build from\n");
        return;
    }
    node** heap = (node**) malloc(sizeof(node*) * heapSize);
    createHeap(heap, root, 0);
    buildHeap(heap, heapSize);
    buildHuffmanTree(heap, &heapSize);
    int huffmanSize = getSize(heap[0]);
    int* huffmanCodeArr = (int*) malloc(sizeof(int) * huffmanSize);
    int lengthOfEncoding = 0;
    encode(heap[0], huffmanCodeArr, lengthOfEncoding);
    int codebookFD = open(huffmanPath, O_RDWR | O_CREAT, 00600);
    writeHuffmanCodebook(codebookFD, heap[0]);
    close(codebookFD);
    freeHuffman(heap[0]);
    free(heap);
    free(huffmanCodeArr);
}

int isDirectory(char* path)
{
    int fd = open(path, O_RDWR);

    if(fd == -1 && errno == EISDIR)
        return 1;

    close(fd);
    return 0;
}

void printAllFiles(char* basePath)
{
    DIR* dir = opendir(basePath);
    readdir(dir);
    readdir(dir);
    char path[10000];

    struct dirent* entry;

    while((entry = readdir(dir)) != NULL)
    {
        strcpy(path, basePath);
        strcat(path, "/");
        strcat(path, entry->d_name);

        if(isDirectory(path))
            printAllFiles(path);
        //else
            //buildReadFile(path);
    }
    
    closedir(dir);
}

node* buildAVLRecursive(char* basePath, node* root)
{
    DIR* dir = opendir(basePath); 
    // 2 reads to skip past parent and current directory
    readdir(dir);
    readdir(dir);

    char path[10000];

    struct dirent* entry;

    while((entry = readdir(dir)) != NULL)
    { // still an entry to be read from the directory
        strcpy(path, basePath);
        strcat(path, "/");
        strcat(path, entry->d_name);

        if(isDirectory(path))
            root = buildAVLRecursive(path, root);
        else
            root = buildAVLFromFile(path, root);   
    }

    closedir(dir);

    return root;
}

char* getFileExtension(char* fileName)
{
    char* ext = strrchr(fileName, '.');
    if(ext == NULL)
        return "";
    return ext+1;
}

char* createHuffmanPath(char* path)
{
    int sizeOfParentPath = 0;
    int index = strlen(path);
    while(index != 0 && path[index] != '/')
    {
        index--;
    }
    char* huffmanPath = (char*) malloc(sizeof(char) * (index+17));
    memset(huffmanPath, '\0', index+12);
    memcpy(huffmanPath, path, index+1);
    strcat(huffmanPath, "HuffmanCodebook");

    return huffmanPath;
}